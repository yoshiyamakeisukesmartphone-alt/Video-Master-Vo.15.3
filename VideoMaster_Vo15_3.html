<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Video Master Vo.15.3</title>
<link rel="manifest" href="manifest.json">
<style>
  :root{
    --bg:#0f1724; --fg:#e6eef6; --panel:#0b1220; --accent:#06b6d4; --danger:#ff3b30;
  }
  [data-theme="light"]{
    --bg:#f5f7fb; --fg:#0b2233; --panel:#ffffff; --accent:#0b63ff; --danger:#e11d48;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  .wrap{max-width:1200px;margin:12px auto;padding:10px;display:flex;flex-wrap:wrap;gap:12px;box-sizing:border-box}
  h1{width:100%;text-align:center;margin:8px 0 6px 0}
  .panel{background:var(--panel);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.28);width:320px;box-sizing:border-box}
  .panel.full{width:100%;max-width:760px}
  input[type=text]{width:100%;padding:8px;border-radius:8px;border:none;background:rgba(255,255,255,0.03);color:var(--fg);box-sizing:border-box}
  ul{list-style:none;margin:8px 0;padding:0;max-height:320px;overflow:auto}
  li{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px;margin:6px 0;background:rgba(255,255,255,0.02);user-select:none}
  .name{flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;cursor:grab}
  button{background:var(--accent);border:none;color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer}
  .small{font-size:13px;padding:4px 8px}
  .danger{background:var(--danger)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:8px}
  audio{width:100%;max-width:760px;border-radius:10px;background:#000;display:block;margin:8px auto}
  .topbar{display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:8px;flex-wrap:wrap}
  .hint{font-size:13px;color:rgba(255,255,255,0.6);margin-top:6px}
  @media(max-width:900px){.panel{width:100%}.panel.full{order:3}}
</style>
<!-- Sortable for drag&drop reordering -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body data-theme="dark">
  <h1>🎧 Video Master Vo.15.3</h1>

  <div class="topbar">
    <button id="themeToggle" class="small">🌗 テーマ切替</button>
    <label class="small"><input type="checkbox" id="tempMode"> 一時再生（保存しない）</label>
    <button id="clearTemp" class="small">一時キューをクリア</button>
  </div>

  <div class="wrap">
    <div class="panel">
      <h3>プレイリスト</h3>
      <input id="playlistSearch" type="text" placeholder="🔍 プレイリスト検索">
      <ul id="playlistList"></ul>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button id="addPlaylist">＋ 新規</button>
        <button id="exportBtn" class="small">エクスポート</button>
      </div>
      <div class="hint">プレイリストはIndexedDBに保存されます。</div>
    </div>

    <div class="panel">
      <h3>ファイル</h3>
      <input id="fileSearch" type="text" placeholder="🔍 曲を検索">
      <ul id="fileList"></ul>
      <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
        <label for="fileInput" style="background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;cursor:pointer">＋ ファイルを追加</label>
        <input id="fileInput" type="file" accept="audio/*" multiple style="display:none">
        <button id="addFilesBtn" class="small">追加</button>
      </div>
      <div class="hint">ドラッグで並べ替え可能。保存したくないときは「一時再生」をチェック。</div>
    </div>

    <div class="panel full">
      <audio id="player" controls playsinline></audio>
      <div class="controls">
        <button id="prevBtn">⏮ 前</button>
        <button id="playBtn">▶ 再生</button>
        <button id="pauseBtn">⏸ 停止</button>
        <button id="nextBtn">⏭ 次</button>
        <button id="loopBtn">🔁 ループ：オン</button>
        <button id="fullscreenBtn">⛶ 全画面</button>
      </div>
      <div class="hint">GitHub Pages にアップして「ホーム画面に追加」すると PWA として使えます（Android で強力）。</div>
    </div>
  </div>

<script>
/*  Video Master Vo.15.3 - single file
    - Audio-only player
    - IndexedDB storage for playlists
    - Drag & drop reorder (Sortable.js)
    - Temporary (non-saved) queue mode
    - Background robustness (AudioContext + visibility handlers + hidden-ended checker)
*/

// state
let playlists = []; // {name, files:[{name,data}]}
let currentPlaylist = null; // name or null (null used for "no playlist selected")
let currentIndex = 0;
let loopMode = true;
let tempQueue = [];
let db = null;
let audioCtx = null;
let mediaSource = null;
let resumeOnReturn = false;
let hiddenEndedCheckTimer = null;

// IndexedDB setup
const openReq = indexedDB.open('VideoMaster_v15_3', 1);
openReq.onupgradeneeded = e => {
  db = e.target.result;
  if(!db.objectStoreNames.contains('playlists')) db.createObjectStore('playlists', {keyPath:'name'});
};
openReq.onsuccess = e => {
  db = e.target.result;
  loadPlaylists();
  // restore theme
  const saved = localStorage.getItem('vm-theme');
  if(saved) document.documentElement.dataset.theme = saved;
};
openReq.onerror = e => console.error('IndexedDB error', e);

// DB helpers
function savePlaylists(){
  if(!db) return;
  const tx = db.transaction('playlists','readwrite');
  const store = tx.objectStore('playlists');
  store.clear();
  for(const p of playlists) store.put(p);
}
function loadPlaylists(){
  if(!db) return;
  const tx = db.transaction('playlists','readonly');
  const store = tx.objectStore('playlists');
  const getAll = store.getAll();
  getAll.onsuccess = () => {
    playlists = getAll.result || [];
    renderPlaylists();
    // if some playlist exists and none selected, pick first
    if(playlists.length>0 && !currentPlaylist) selectPlaylist(playlists[0].name);
  };
}

// rendering
function renderPlaylists(){
  const q = document.getElementById('playlistSearch').value.toLowerCase();
  const ul = document.getElementById('playlistList');
  ul.innerHTML = '';
  playlists.filter(p => p.name.toLowerCase().includes(q)).forEach(p => {
    const li = document.createElement('li');
    const span = document.createElement('span'); span.className='name'; span.textContent = p.name; span.onclick = ()=>selectPlaylist(p.name);
    const ren = document.createElement('button'); ren.textContent='✏️'; ren.className='small';
    ren.onclick = e => { e.stopPropagation(); const nn = prompt('新しいプレイリスト名', p.name); if(nn){ p.name = nn; savePlaylists(); renderPlaylists(); } };
    const del = document.createElement('button'); del.textContent='×'; del.className='danger';
    del.onclick = e => { e.stopPropagation(); if(confirm(`「${p.name}」を削除しますか？`)){ playlists = playlists.filter(x=>x.name!==p.name); savePlaylists(); renderPlaylists(); if(currentPlaylist===p.name){ currentPlaylist=null; renderFiles(); } } };
    li.append(span, ren, del);
    ul.appendChild(li);
  });
  // temporary queue pseudo-item
  const tmp = document.createElement('li'); tmp.style.background='rgba(255,255,255,0.02)'; tmp.innerHTML = '<span class="name">▶ 一時キュー（保存されません）</span>';
  tmp.onclick = ()=>{ currentPlaylist = null; renderFiles(); };
  ul.appendChild(tmp);
}

function renderFiles(){
  const q = document.getElementById('fileSearch').value.toLowerCase();
  const ul = document.getElementById('fileList');
  ul.innerHTML = '';
  let files = (document.getElementById('tempMode').checked || currentPlaylist===null) ? tempQueue : (playlists.find(p=>p.name===currentPlaylist)?.files || []);
  files.filter(f => f.name.toLowerCase().includes(q)).forEach((f,i) => {
    const li = document.createElement('li');
    const span = document.createElement('span'); span.className='name'; span.textContent = f.name; span.onclick = ()=>playFileIndex(i);
    const ren = document.createElement('button'); ren.textContent='✏️'; ren.className='small';
    ren.onclick = e => { e.stopPropagation(); const nn = prompt('新しい曲名', f.name); if(nn){ f.name = nn; if(!document.getElementById('tempMode').checked && currentPlaylist){ const pl = playlists.find(p=>p.name===currentPlaylist); if(pl) pl.files = files; savePlaylists(); } renderFiles(); } };
    const del = document.createElement('button'); del.textContent='×'; del.className='danger';
    del.onclick = e => { e.stopPropagation(); if(confirm(`${f.name} を削除しますか？`)){ files.splice(i,1); if(!document.getElementById('tempMode').checked && currentPlaylist){ const pl = playlists.find(p=>p.name===currentPlaylist); if(pl) pl.files = files; savePlaylists(); } renderFiles(); } };
    li.append(span, ren, del);
    ul.appendChild(li);
  });

  // make sortable (destroy previous if exists)
  if(window.fileSortable) window.fileSortable.destroy();
  window.fileSortable = Sortable.create(ul, {
    animation: 150,
    handle: '.name',
    onEnd: function(evt){
      const oldIndex = evt.oldIndex, newIndex = evt.newIndex;
      if(oldIndex===newIndex) return;
      const arr = (document.getElementById('tempMode').checked || currentPlaylist===null) ? tempQueue : (playlists.find(p=>p.name===currentPlaylist)?.files || []);
      const [moved] = arr.splice(oldIndex,1);
      arr.splice(newIndex,0,moved);
      if(!document.getElementById('tempMode').checked && currentPlaylist){
        const pl = playlists.find(p=>p.name===currentPlaylist); if(pl) pl.files = arr; savePlaylists();
      }
      renderFiles();
    }
  });
}

// helpers
function fileToBase64(file){
  return new Promise((res,rej)=>{
    const reader = new FileReader();
    reader.onload = ()=>res(reader.result);
    reader.onerror = rej;
    reader.readAsDataURL(file);
  });
}

function selectPlaylist(name){
  currentPlaylist = name;
  renderFiles();
}

// interactions
document.getElementById('addPlaylist').onclick = ()=>{
  const name = prompt('プレイリスト名');
  if(!name) return;
  playlists.push({name, files: []});
  savePlaylists();
  renderPlaylists();
};

document.getElementById('playlistSearch').oninput = renderPlaylists;
document.getElementById('fileSearch').oninput = renderFiles;

document.getElementById('addFilesBtn').onclick = ()=> document.getElementById('fileInput').click();
document.getElementById('fileInput').onchange = async (e) => {
  const files = [...e.target.files];
  if(document.getElementById('tempMode').checked || currentPlaylist===null){
    for(const f of files){ const data = await fileToBase64(f); tempQueue.push({name:f.name, data}); }
    renderFiles();
  } else {
    if(!currentPlaylist){ alert('プレイリストを選択してください'); e.target.value=''; return; }
    const pl = playlists.find(p=>p.name===currentPlaylist);
    for(const f of files){ const data = await fileToBase64(f); pl.files.push({name:f.name, data}); }
    savePlaylists(); renderFiles();
  }
  e.target.value = '';
};

document.getElementById('clearTemp').onclick = ()=>{ if(confirm('一時キューをクリアしますか？')){ tempQueue = []; renderFiles(); } };

// playback
const player = document.getElementById('player');

function getQueue(){ return (document.getElementById('tempMode').checked || currentPlaylist===null) ? tempQueue : (playlists.find(p=>p.name===currentPlaylist)?.files || []); }

function playFileIndex(i){
  const q = getQueue();
  if(!q || !q[i]) return;
  const item = q[i];
  player.src = item.data;
  player.play().catch(()=>{});
  currentIndex = i;
  ensureAudioContextConnected();
}

document.getElementById('playBtn').onclick = ()=>{ player.play().catch(()=>{}); ensureAudioContextConnected(); };
document.getElementById('pauseBtn').onclick = ()=> player.pause();
document.getElementById('prevBtn').onclick = ()=> { const q = getQueue(); if(!q || q.length===0) return; currentIndex = (currentIndex - 1 + q.length) % q.length; playFileIndex(currentIndex); };
document.getElementById('nextBtn').onclick = ()=> nextTrack();
document.getElementById('loopBtn').onclick = ()=> { loopMode = !loopMode; player.loop = false; document.getElementById('loopBtn').textContent = `🔁 ループ：${loopMode ? 'オン' : 'オフ'}`; };
document.getElementById('fullscreenBtn').onclick = ()=> { if(player.requestFullscreen) player.requestFullscreen(); else if(player.webkitEnterFullscreen) player.webkitEnterFullscreen(); };

function nextTrack(){
  const q = getQueue();
  if(!q || q.length===0) return;
  if(currentIndex < q.length - 1){ currentIndex++; playFileIndex(currentIndex); }
  else if(loopMode){ currentIndex = 0; playFileIndex(currentIndex); }
}

// ended handler
player.addEventListener('ended', ()=>{ nextTrack(); });

// AudioContext to improve background behavior
function ensureAudioContextConnected(){
  try{
    if(!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    if(audioCtx.state === 'suspended'){ audioCtx.resume().catch(()=>{}); }
    if(!mediaSource){
      try{ mediaSource = audioCtx.createMediaElementSource(player); mediaSource.connect(audioCtx.destination); }
      catch(e){ /* some browsers block cross-origin or multiple creates */ }
    }
  }catch(e){ console.warn('AudioContext error', e); }
}

// Robust background handling
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    if(!player.paused) resumeOnReturn = true;
    startHiddenEndedChecker();
  } else {
    if(resumeOnReturn){ player.play().catch(()=>{}); resumeOnReturn = false; }
    stopHiddenEndedChecker();
  }
});
window.addEventListener('pagehide', ()=>{ if(!player.paused) resumeOnReturn = true; startHiddenEndedChecker(); });
window.addEventListener('pageshow', ()=>{ if(resumeOnReturn){ player.play().catch(()=>{}); resumeOnReturn = false; } stopHiddenEndedChecker(); });

function startHiddenEndedChecker(){
  stopHiddenEndedChecker();
  // check periodically whether playback time reached duration while hidden
  hiddenEndedCheckTimer = setInterval(()=>{
    if(player.duration && player.currentTime >= player.duration - 0.5){
      nextTrack();
    }
  }, 800);
}
function stopHiddenEndedChecker(){ if(hiddenEndedCheckTimer){ clearInterval(hiddenEndedCheckTimer); hiddenEndedCheckTimer = null; } }

// drag-drop file to file list (for convenience)
const fileListEl = document.getElementById('fileList');
['dragover','dragenter'].forEach(ev => fileListEl.addEventListener(ev, e => { e.preventDefault(); fileListEl.style.outline='2px dashed rgba(6,182,212,0.4)'; }));
['dragleave','drop'].forEach(ev => fileListEl.addEventListener(ev, e => { e.preventDefault(); fileListEl.style.outline=''; }));
fileListEl.addEventListener('drop', async e => {
  e.preventDefault();
  const dt = e.dataTransfer;
  if(!dt) return;
  const files = Array.from(dt.files || []);
  if(files.length === 0) return;
  if(document.getElementById('tempMode').checked || currentPlaylist===null){
    for(const f of files){ const data = await fileToBase64(f); tempQueue.push({name:f.name, data}); }
    renderFiles();
  } else {
    const pl = playlists.find(p=>p.name===currentPlaylist);
    for(const f of files){ const data = await fileToBase64(f); pl.files.push({name:f.name, data}); }
    savePlaylists(); renderFiles();
  }
});

// export/import helpers
document.getElementById('exportBtn').onclick = ()=> {
  const data = JSON.stringify(playlists);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'playlists.json'; a.click(); URL.revokeObjectURL(url);
};

// theme toggle
document.getElementById('themeToggle').onclick = ()=>{
  const html = document.documentElement;
  html.dataset.theme = html.dataset.theme === 'light' ? 'dark' : 'light';
  localStorage.setItem('vm-theme', html.dataset.theme);
};

// Service Worker registration (if hosted on http(s))
if('serviceWorker' in navigator){
  navigator.serviceWorker.register('service-worker.js').then(r => {
    console.log('SW registered', r);
  }).catch(err => console.warn('SW failed', err));
}

// initial render
setTimeout(()=>{ renderPlaylists(); renderFiles(); }, 200);
</script>
</body>
</html>
